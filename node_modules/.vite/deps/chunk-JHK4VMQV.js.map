{
  "version": 3,
  "sources": ["../../@solana/wallet-adapter-react/src/ConnectionProvider.tsx", "../../@solana/wallet-adapter-react/src/useConnection.ts", "../../@solana/wallet-adapter-react/src/errors.ts", "../../@solana/wallet-adapter-react/src/useAnchorWallet.ts", "../../@solana/wallet-adapter-react/src/useWallet.ts", "../../@solana/wallet-adapter-react/src/useLocalStorage.ts", "../../@solana/wallet-standard-wallet-adapter-react/node_modules/@solana/wallet-standard-wallet-adapter-base/src/adapter.ts", "../../@solana/wallet-standard-wallet-adapter-react/node_modules/@solana/wallet-standard-wallet-adapter-base/src/types.ts", "../../@wallet-standard/app/src/wallets.ts", "../../@solana/wallet-standard-wallet-adapter-react/node_modules/@solana/wallet-standard-wallet-adapter-base/src/wallet.ts", "../../@solana/wallet-standard-wallet-adapter-react/src/useStandardWalletAdapters.ts", "../../@solana/wallet-adapter-react/src/WalletProvider.tsx", "../../@solana/wallet-adapter-react/src/getEnvironment.ts", "../../@solana/wallet-adapter-react/src/getInferredClusterFromEndpoint.ts", "../../@solana/wallet-adapter-react/src/WalletProviderBase.tsx"],
  "sourcesContent": ["import { Connection, type ConnectionConfig } from '@solana/web3.js';\nimport React, { type FC, type ReactNode, useMemo } from 'react';\nimport { ConnectionContext } from './useConnection.js';\n\nexport interface ConnectionProviderProps {\n    children: ReactNode;\n    endpoint: string;\n    config?: ConnectionConfig;\n}\n\nexport const ConnectionProvider: FC<ConnectionProviderProps> = ({\n    children,\n    endpoint,\n    config = { commitment: 'confirmed' },\n}) => {\n    const connection = useMemo(() => new Connection(endpoint, config), [endpoint, config]);\n\n    return <ConnectionContext.Provider value={{ connection }}>{children}</ConnectionContext.Provider>;\n};\n", "import { type Connection } from '@solana/web3.js';\nimport { createContext, useContext } from 'react';\n\nexport interface ConnectionContextState {\n    connection: Connection;\n}\n\nexport const ConnectionContext = createContext<ConnectionContextState>({} as ConnectionContextState);\n\nexport function useConnection(): ConnectionContextState {\n    return useContext(ConnectionContext);\n}\n", "import { WalletError } from '@solana/wallet-adapter-base';\n\nexport class WalletNotSelectedError extends WalletError {\n    name = 'WalletNotSelectedError';\n}\n", "import { type PublicKey, type Transaction, type VersionedTransaction } from '@solana/web3.js';\nimport { useMemo } from 'react';\nimport { useWallet } from './useWallet.js';\n\nexport interface AnchorWallet {\n    publicKey: PublicKey;\n    signTransaction<T extends Transaction | VersionedTransaction>(transaction: T): Promise<T>;\n    signAllTransactions<T extends Transaction | VersionedTransaction>(transactions: T[]): Promise<T[]>;\n}\n\nexport function useAnchorWallet(): AnchorWallet | undefined {\n    const { publicKey, signTransaction, signAllTransactions } = useWallet();\n    return useMemo(\n        () =>\n            publicKey && signTransaction && signAllTransactions\n                ? { publicKey, signTransaction, signAllTransactions }\n                : undefined,\n        [publicKey, signTransaction, signAllTransactions]\n    );\n}\n", "import {\n    type Adapter,\n    type MessageSignerWalletAdapterProps,\n    type SignerWalletAdapterProps,\n    type SignInMessageSignerWalletAdapterProps,\n    type WalletAdapterProps,\n    type WalletName,\n    type WalletReadyState,\n} from '@solana/wallet-adapter-base';\nimport { type PublicKey } from '@solana/web3.js';\nimport { createContext, useContext } from 'react';\n\nexport interface Wallet {\n    adapter: Adapter;\n    readyState: WalletReadyState;\n}\n\nexport interface WalletContextState {\n    autoConnect: boolean;\n    wallets: Wallet[];\n    wallet: Wallet | null;\n    publicKey: PublicKey | null;\n    connecting: boolean;\n    connected: boolean;\n    disconnecting: boolean;\n\n    select(walletName: WalletName | null): void;\n    connect(): Promise<void>;\n    disconnect(): Promise<void>;\n\n    sendTransaction: WalletAdapterProps['sendTransaction'];\n    signTransaction: SignerWalletAdapterProps['signTransaction'] | undefined;\n    signAllTransactions: SignerWalletAdapterProps['signAllTransactions'] | undefined;\n    signMessage: MessageSignerWalletAdapterProps['signMessage'] | undefined;\n    signIn: SignInMessageSignerWalletAdapterProps['signIn'] | undefined;\n}\n\nconst EMPTY_ARRAY: ReadonlyArray<never> = [];\n\nconst DEFAULT_CONTEXT: Partial<WalletContextState> = {\n    autoConnect: false,\n    connecting: false,\n    connected: false,\n    disconnecting: false,\n    select() {\n        logMissingProviderError('call', 'select');\n    },\n    connect() {\n        return Promise.reject(logMissingProviderError('call', 'connect'));\n    },\n    disconnect() {\n        return Promise.reject(logMissingProviderError('call', 'disconnect'));\n    },\n    sendTransaction() {\n        return Promise.reject(logMissingProviderError('call', 'sendTransaction'));\n    },\n    signTransaction() {\n        return Promise.reject(logMissingProviderError('call', 'signTransaction'));\n    },\n    signAllTransactions() {\n        return Promise.reject(logMissingProviderError('call', 'signAllTransactions'));\n    },\n    signMessage() {\n        return Promise.reject(logMissingProviderError('call', 'signMessage'));\n    },\n    signIn() {\n        return Promise.reject(logMissingProviderError('call', 'signIn'));\n    },\n};\nObject.defineProperty(DEFAULT_CONTEXT, 'wallets', {\n    get() {\n        logMissingProviderError('read', 'wallets');\n        return EMPTY_ARRAY;\n    },\n});\nObject.defineProperty(DEFAULT_CONTEXT, 'wallet', {\n    get() {\n        logMissingProviderError('read', 'wallet');\n        return null;\n    },\n});\nObject.defineProperty(DEFAULT_CONTEXT, 'publicKey', {\n    get() {\n        logMissingProviderError('read', 'publicKey');\n        return null;\n    },\n});\n\nfunction logMissingProviderError(action: string, property: string) {\n    const error = new Error(\n        `You have tried to ${action} \"${property}\" on a WalletContext without providing one. ` +\n            'Make sure to render a WalletProvider as an ancestor of the component that uses WalletContext.'\n    );\n    console.error(error);\n    return error;\n}\n\nexport const WalletContext = createContext<WalletContextState>(DEFAULT_CONTEXT as WalletContextState);\n\nexport function useWallet(): WalletContextState {\n    return useContext(WalletContext);\n}\n", "import { type Dispatch, type SetStateAction, useEffect, useRef, useState } from 'react';\n\nexport function useLocalStorage<T>(key: string, defaultState: T): [T, Dispatch<SetStateAction<T>>] {\n    const state = useState<T>(() => {\n        try {\n            const value = localStorage.getItem(key);\n            if (value) return JSON.parse(value) as T;\n        } catch (error: any) {\n            if (typeof window !== 'undefined') {\n                console.error(error);\n            }\n        }\n\n        return defaultState;\n    });\n    const value = state[0];\n\n    const isFirstRenderRef = useRef(true);\n    useEffect(() => {\n        if (isFirstRenderRef.current) {\n            isFirstRenderRef.current = false;\n            return;\n        }\n        try {\n            if (value === null) {\n                localStorage.removeItem(key);\n            } else {\n                localStorage.setItem(key, JSON.stringify(value));\n            }\n        } catch (error: any) {\n            if (typeof window !== 'undefined') {\n                console.error(error);\n            }\n        }\n    }, [value, key]);\n\n    return state;\n}\n", "import {\n    BaseWalletAdapter,\n    isVersionedTransaction,\n    type SendTransactionOptions,\n    type StandardWalletAdapter as StandardWalletAdapterType,\n    type SupportedTransactionVersions,\n    WalletAccountError,\n    type WalletAdapterCompatibleStandardWallet,\n    WalletConfigError,\n    WalletConnectionError,\n    WalletDisconnectedError,\n    WalletDisconnectionError,\n    WalletError,\n    type WalletName,\n    WalletNotConnectedError,\n    WalletNotReadyError,\n    WalletPublicKeyError,\n    WalletReadyState,\n    WalletSendTransactionError,\n    WalletSignInError,\n    WalletSignMessageError,\n    WalletSignTransactionError,\n} from '@solana/wallet-adapter-base';\nimport {\n    SolanaSignAndSendTransaction,\n    type SolanaSignAndSendTransactionFeature,\n    SolanaSignIn,\n    type SolanaSignInInput,\n    type SolanaSignInOutput,\n    SolanaSignMessage,\n    SolanaSignTransaction,\n    type SolanaSignTransactionFeature,\n} from '@solana/wallet-standard-features';\nimport { getChainForEndpoint, getCommitment } from '@solana/wallet-standard-util';\nimport type { Connection, TransactionSignature } from '@solana/web3.js';\nimport { PublicKey, Transaction, VersionedTransaction } from '@solana/web3.js';\nimport type { WalletAccount } from '@wallet-standard/base';\nimport {\n    StandardConnect,\n    type StandardConnectInput,\n    StandardDisconnect,\n    StandardEvents,\n    type StandardEventsListeners,\n} from '@wallet-standard/features';\nimport { arraysEqual } from '@wallet-standard/wallet';\nimport bs58 from 'bs58';\n\n/** TODO: docs */\nexport interface StandardWalletAdapterConfig {\n    wallet: WalletAdapterCompatibleStandardWallet;\n}\n\n/** TODO: docs */\nexport class StandardWalletAdapter extends BaseWalletAdapter implements StandardWalletAdapterType {\n    #account: WalletAccount | null;\n    #publicKey: PublicKey | null;\n    #connecting: boolean;\n    #disconnecting: boolean;\n    #off: (() => void) | null;\n    #supportedTransactionVersions: SupportedTransactionVersions;\n    readonly #wallet: WalletAdapterCompatibleStandardWallet;\n    readonly #readyState: WalletReadyState =\n        typeof window === 'undefined' || typeof document === 'undefined'\n            ? WalletReadyState.Unsupported\n            : WalletReadyState.Installed;\n\n    get name() {\n        return this.#wallet.name as WalletName;\n    }\n\n    get url() {\n        return 'https://github.com/solana-labs/wallet-standard';\n    }\n\n    get icon() {\n        return this.#wallet.icon;\n    }\n\n    get readyState() {\n        return this.#readyState;\n    }\n\n    get publicKey() {\n        return this.#publicKey;\n    }\n\n    get connecting() {\n        return this.#connecting;\n    }\n\n    get supportedTransactionVersions() {\n        return this.#supportedTransactionVersions;\n    }\n\n    get wallet(): WalletAdapterCompatibleStandardWallet {\n        return this.#wallet;\n    }\n\n    get standard() {\n        return true as const;\n    }\n\n    constructor({ wallet }: StandardWalletAdapterConfig) {\n        super();\n\n        this.#wallet = wallet;\n        this.#account = null;\n        this.#publicKey = null;\n        this.#connecting = false;\n        this.#disconnecting = false;\n        this.#off = this.#wallet.features[StandardEvents].on('change', this.#changed);\n\n        this.#reset();\n    }\n\n    destroy(): void {\n        this.#account = null;\n        this.#publicKey = null;\n        this.#connecting = false;\n        this.#disconnecting = false;\n\n        const off = this.#off;\n        if (off) {\n            this.#off = null;\n            off();\n        }\n    }\n\n    async autoConnect(): Promise<void> {\n        return this.#connect({ silent: true });\n    }\n\n    async connect(): Promise<void> {\n        return this.#connect();\n    }\n\n    async #connect(input?: StandardConnectInput): Promise<void> {\n        try {\n            if (this.connected || this.connecting) return;\n            if (this.#readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();\n\n            this.#connecting = true;\n\n            if (!this.#wallet.accounts.length) {\n                try {\n                    await this.#wallet.features[StandardConnect].connect(input);\n                } catch (error: any) {\n                    throw new WalletConnectionError(error?.message, error);\n                }\n            }\n\n            const account = this.#wallet.accounts[0];\n            if (!account) throw new WalletAccountError();\n\n            this.#connected(account);\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        } finally {\n            this.#connecting = false;\n        }\n    }\n\n    async disconnect(): Promise<void> {\n        if (StandardDisconnect in this.#wallet.features) {\n            try {\n                this.#disconnecting = true;\n                await this.#wallet.features[StandardDisconnect].disconnect();\n            } catch (error: any) {\n                this.emit('error', new WalletDisconnectionError(error?.message, error));\n            } finally {\n                this.#disconnecting = false;\n            }\n        }\n\n        this.#disconnected();\n    }\n\n    #connected(account: WalletAccount) {\n        let publicKey: PublicKey;\n        try {\n            // Use account.address instead of account.publicKey since address could be a PDA\n            publicKey = new PublicKey(account.address);\n        } catch (error: any) {\n            throw new WalletPublicKeyError(error?.message, error);\n        }\n\n        this.#account = account;\n        this.#publicKey = publicKey;\n        this.#reset();\n        this.emit('connect', publicKey);\n    }\n\n    #disconnected(): void {\n        this.#account = null;\n        this.#publicKey = null;\n        this.#reset();\n        this.emit('disconnect');\n    }\n\n    #reset() {\n        const supportedTransactionVersions =\n            SolanaSignAndSendTransaction in this.#wallet.features\n                ? this.#wallet.features[SolanaSignAndSendTransaction].supportedTransactionVersions\n                : this.#wallet.features[SolanaSignTransaction].supportedTransactionVersions;\n        this.#supportedTransactionVersions = arraysEqual(supportedTransactionVersions, ['legacy'])\n            ? null\n            : new Set(supportedTransactionVersions);\n\n        if (SolanaSignTransaction in this.#wallet.features && this.#account?.features.includes(SolanaSignTransaction)) {\n            this.signTransaction = this.#signTransaction;\n            this.signAllTransactions = this.#signAllTransactions;\n        } else {\n            delete this.signTransaction;\n            delete this.signAllTransactions;\n        }\n\n        if (SolanaSignMessage in this.#wallet.features && this.#account?.features.includes(SolanaSignMessage)) {\n            this.signMessage = this.#signMessage;\n        } else {\n            delete this.signMessage;\n        }\n\n        if (SolanaSignIn in this.#wallet.features) {\n            this.signIn = this.#signIn;\n        } else {\n            delete this.signIn;\n        }\n    }\n\n    #changed: StandardEventsListeners['change'] = (properties) => {\n        // If accounts have changed on the wallet, reflect this on the adapter.\n        if ('accounts' in properties) {\n            const account = this.#wallet.accounts[0];\n            // If the adapter isn't connected, or is disconnecting, or the first account hasn't changed, do nothing.\n            if (this.#account && !this.#disconnecting && account !== this.#account) {\n                // If there's a connected account, connect the adapter. Otherwise, disconnect it.\n                if (account) {\n                    // Connect the adapter.\n                    this.#connected(account);\n                } else {\n                    // Emit an error because the wallet spontaneously disconnected.\n                    this.emit('error', new WalletDisconnectedError());\n                    // Disconnect the adapter.\n                    this.#disconnected();\n                }\n            }\n        }\n\n        // After reflecting account changes, if features have changed on the wallet, reflect this on the adapter.\n        if ('features' in properties) {\n            this.#reset();\n        }\n    };\n\n    async sendTransaction<T extends Transaction | VersionedTransaction>(\n        transaction: T,\n        connection: Connection,\n        options: SendTransactionOptions = {}\n    ): Promise<TransactionSignature> {\n        try {\n            const account = this.#account;\n            if (!account) throw new WalletNotConnectedError();\n\n            let feature: typeof SolanaSignAndSendTransaction | typeof SolanaSignTransaction;\n            if (SolanaSignAndSendTransaction in this.#wallet.features) {\n                if (account.features.includes(SolanaSignAndSendTransaction)) {\n                    feature = SolanaSignAndSendTransaction;\n                } else if (\n                    SolanaSignTransaction in this.#wallet.features &&\n                    account.features.includes(SolanaSignTransaction)\n                ) {\n                    feature = SolanaSignTransaction;\n                } else {\n                    throw new WalletAccountError();\n                }\n            } else if (SolanaSignTransaction in this.#wallet.features) {\n                if (!account.features.includes(SolanaSignTransaction)) throw new WalletAccountError();\n                feature = SolanaSignTransaction;\n            } else {\n                throw new WalletConfigError();\n            }\n\n            const chain = getChainForEndpoint(connection.rpcEndpoint);\n            if (!account.chains.includes(chain)) throw new WalletSendTransactionError();\n\n            try {\n                const { signers, ...sendOptions } = options;\n\n                let serializedTransaction: Uint8Array;\n                if (isVersionedTransaction(transaction)) {\n                    signers?.length && transaction.sign(signers);\n                    serializedTransaction = transaction.serialize();\n                } else {\n                    transaction = (await this.prepareTransaction(transaction, connection, sendOptions)) as T;\n                    signers?.length && (transaction as Transaction).partialSign(...signers);\n                    serializedTransaction = new Uint8Array(\n                        (transaction as Transaction).serialize({\n                            requireAllSignatures: false,\n                            verifySignatures: false,\n                        })\n                    );\n                }\n\n                if (feature === SolanaSignAndSendTransaction) {\n                    const [output] = await (this.#wallet.features as SolanaSignAndSendTransactionFeature)[\n                        SolanaSignAndSendTransaction\n                    ].signAndSendTransaction({\n                        account,\n                        chain,\n                        transaction: serializedTransaction,\n                        options: {\n                            preflightCommitment: getCommitment(\n                                sendOptions.preflightCommitment || connection.commitment\n                            ),\n                            skipPreflight: sendOptions.skipPreflight,\n                            maxRetries: sendOptions.maxRetries,\n                            minContextSlot: sendOptions.minContextSlot,\n                        },\n                    });\n\n                    return bs58.encode(output!.signature);\n                } else {\n                    const [output] = await (this.#wallet.features as SolanaSignTransactionFeature)[\n                        SolanaSignTransaction\n                    ].signTransaction({\n                        account,\n                        chain,\n                        transaction: serializedTransaction,\n                        options: {\n                            preflightCommitment: getCommitment(\n                                sendOptions.preflightCommitment || connection.commitment\n                            ),\n                            minContextSlot: sendOptions.minContextSlot,\n                        },\n                    });\n\n                    return await connection.sendRawTransaction(output!.signedTransaction, {\n                        ...sendOptions,\n                        preflightCommitment: getCommitment(sendOptions.preflightCommitment || connection.commitment),\n                    });\n                }\n            } catch (error: any) {\n                if (error instanceof WalletError) throw error;\n                throw new WalletSendTransactionError(error?.message, error);\n            }\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n\n    signTransaction: (<T extends Transaction | VersionedTransaction>(transaction: T) => Promise<T>) | undefined;\n    async #signTransaction<T extends Transaction | VersionedTransaction>(transaction: T): Promise<T> {\n        try {\n            const account = this.#account;\n            if (!account) throw new WalletNotConnectedError();\n\n            if (!(SolanaSignTransaction in this.#wallet.features)) throw new WalletConfigError();\n            if (!account.features.includes(SolanaSignTransaction)) throw new WalletAccountError();\n\n            try {\n                const signedTransactions = await this.#wallet.features[SolanaSignTransaction].signTransaction({\n                    account,\n                    transaction: isVersionedTransaction(transaction)\n                        ? transaction.serialize()\n                        : new Uint8Array(\n                              transaction.serialize({\n                                  requireAllSignatures: false,\n                                  verifySignatures: false,\n                              })\n                          ),\n                });\n\n                const serializedTransaction = signedTransactions[0]!.signedTransaction;\n\n                return (\n                    isVersionedTransaction(transaction)\n                        ? VersionedTransaction.deserialize(serializedTransaction)\n                        : Transaction.from(serializedTransaction)\n                ) as T;\n            } catch (error: any) {\n                if (error instanceof WalletError) throw error;\n                throw new WalletSignTransactionError(error?.message, error);\n            }\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n\n    signAllTransactions: (<T extends Transaction | VersionedTransaction>(transaction: T[]) => Promise<T[]>) | undefined;\n    async #signAllTransactions<T extends Transaction | VersionedTransaction>(transactions: T[]): Promise<T[]> {\n        try {\n            const account = this.#account;\n            if (!account) throw new WalletNotConnectedError();\n\n            if (!(SolanaSignTransaction in this.#wallet.features)) throw new WalletConfigError();\n            if (!account.features.includes(SolanaSignTransaction)) throw new WalletAccountError();\n\n            try {\n                const signedTransactions = await this.#wallet.features[SolanaSignTransaction].signTransaction(\n                    ...transactions.map((transaction) => ({\n                        account,\n                        transaction: isVersionedTransaction(transaction)\n                            ? transaction.serialize()\n                            : new Uint8Array(\n                                  transaction.serialize({\n                                      requireAllSignatures: false,\n                                      verifySignatures: false,\n                                  })\n                              ),\n                    }))\n                );\n\n                return transactions.map((transaction, index) => {\n                    const signedTransaction = signedTransactions[index]!.signedTransaction;\n\n                    return (\n                        isVersionedTransaction(transaction)\n                            ? VersionedTransaction.deserialize(signedTransaction)\n                            : Transaction.from(signedTransaction)\n                    ) as T;\n                });\n            } catch (error: any) {\n                throw new WalletSignTransactionError(error?.message, error);\n            }\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n\n    signMessage: ((message: Uint8Array) => Promise<Uint8Array>) | undefined;\n    async #signMessage(message: Uint8Array): Promise<Uint8Array> {\n        try {\n            const account = this.#account;\n            if (!account) throw new WalletNotConnectedError();\n\n            if (!(SolanaSignMessage in this.#wallet.features)) throw new WalletConfigError();\n            if (!account.features.includes(SolanaSignMessage)) throw new WalletAccountError();\n\n            try {\n                const signedMessages = await this.#wallet.features[SolanaSignMessage].signMessage({\n                    account,\n                    message,\n                });\n\n                return signedMessages[0]!.signature;\n            } catch (error: any) {\n                throw new WalletSignMessageError(error?.message, error);\n            }\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n\n    signIn: ((input?: SolanaSignInInput) => Promise<SolanaSignInOutput>) | undefined;\n    async #signIn(input: SolanaSignInInput = {}): Promise<SolanaSignInOutput> {\n        try {\n            if (!(SolanaSignIn in this.#wallet.features)) throw new WalletConfigError();\n\n            let output: SolanaSignInOutput | undefined;\n            try {\n                [output] = await this.#wallet.features[SolanaSignIn].signIn(input);\n            } catch (error: any) {\n                throw new WalletSignInError(error?.message, error);\n            }\n\n            if (!output) throw new WalletSignInError();\n            this.#connected(output.account);\n            return output;\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n}\n", "import {\n    isWalletAdapterCompatibleStandardWallet,\n    type StandardWalletAdapter,\n    type WalletAdapterCompatibleStandardWallet,\n} from '@solana/wallet-adapter-base';\n\n/**\n * @deprecated Use `StandardWalletAdapter` from `@solana/wallet-adapter-base` instead.\n *\n * @group Deprecated\n */\nexport type StandardAdapter = StandardWalletAdapter;\n\n/**\n * @deprecated Use `WalletAdapterCompatibleStandardWallet` from `@solana/wallet-adapter-base` instead.\n *\n * @group Deprecated\n */\nexport type WalletAdapterCompatibleWallet = WalletAdapterCompatibleStandardWallet;\n\n/**\n * @deprecated Use `isWalletAdapterCompatibleStandardWallet` from `@solana/wallet-adapter-base` instead.\n *\n * @group Deprecated\n */\nexport const isWalletAdapterCompatibleWallet = isWalletAdapterCompatibleStandardWallet;\n", "import type {\n    DEPRECATED_WalletsCallback,\n    DEPRECATED_WalletsWindow,\n    Wallet,\n    WalletEventsWindow,\n    WindowAppReadyEvent,\n    WindowAppReadyEventAPI,\n} from '@wallet-standard/base';\n\nlet wallets: Wallets | undefined = undefined;\nconst registeredWalletsSet = new Set<Wallet>();\nfunction addRegisteredWallet(wallet: Wallet) {\n    cachedWalletsArray = undefined;\n    registeredWalletsSet.add(wallet);\n}\nfunction removeRegisteredWallet(wallet: Wallet) {\n    cachedWalletsArray = undefined;\n    registeredWalletsSet.delete(wallet);\n}\nconst listeners: { [E in WalletsEventNames]?: WalletsEventsListeners[E][] } = {};\n\n/**\n * Get an API for {@link Wallets.get | getting}, {@link Wallets.on | listening for}, and\n * {@link Wallets.register | registering} {@link \"@wallet-standard/base\".Wallet | Wallets}.\n *\n * When called for the first time --\n *\n * This dispatches a {@link \"@wallet-standard/base\".WindowAppReadyEvent} to notify each Wallet that the app is ready\n * to register it.\n *\n * This also adds a listener for {@link \"@wallet-standard/base\".WindowRegisterWalletEvent} to listen for a notification\n * from each Wallet that the Wallet is ready to be registered by the app.\n *\n * This combination of event dispatch and listener guarantees that each Wallet will be registered synchronously as soon\n * as the app is ready whether the app loads before or after each Wallet.\n *\n * @return API for getting, listening for, and registering Wallets.\n *\n * @group App\n */\nexport function getWallets(): Wallets {\n    if (wallets) return wallets;\n    wallets = Object.freeze({ register, get, on });\n    if (typeof window === 'undefined') return wallets;\n\n    const api = Object.freeze({ register });\n    try {\n        (window as WalletEventsWindow).addEventListener('wallet-standard:register-wallet', ({ detail: callback }) =>\n            callback(api)\n        );\n    } catch (error) {\n        console.error('wallet-standard:register-wallet event listener could not be added\\n', error);\n    }\n    try {\n        (window as WalletEventsWindow).dispatchEvent(new AppReadyEvent(api));\n    } catch (error) {\n        console.error('wallet-standard:app-ready event could not be dispatched\\n', error);\n    }\n\n    return wallets;\n}\n\n/**\n * API for {@link Wallets.get | getting}, {@link Wallets.on | listening for}, and\n * {@link Wallets.register | registering} {@link \"@wallet-standard/base\".Wallet | Wallets}.\n *\n * @group App\n */\nexport interface Wallets {\n    /**\n     * Get all Wallets that have been registered.\n     *\n     * @return Registered Wallets.\n     */\n    get(): readonly Wallet[];\n\n    /**\n     * Add an event listener and subscribe to events for Wallets that are\n     * {@link WalletsEventsListeners.register | registered} and\n     * {@link WalletsEventsListeners.unregister | unregistered}.\n     *\n     * @param event    Event type to listen for. {@link WalletsEventsListeners.register | `register`} and\n     * {@link WalletsEventsListeners.unregister | `unregister`} are the only event types.\n     * @param listener Function that will be called when an event of the type is emitted.\n     *\n     * @return\n     * `off` function which may be called to remove the event listener and unsubscribe from events.\n     *\n     * As with all event listeners, be careful to avoid memory leaks.\n     */\n    on<E extends WalletsEventNames>(event: E, listener: WalletsEventsListeners[E]): () => void;\n\n    /**\n     * Register Wallets. This can be used to programmatically wrap non-standard wallets as Standard Wallets.\n     *\n     * Apps generally do not need to, and should not, call this.\n     *\n     * @param wallets Wallets to register.\n     *\n     * @return\n     * `unregister` function which may be called to programmatically unregister the registered Wallets.\n     *\n     * Apps generally do not need to, and should not, call this.\n     */\n    register(...wallets: Wallet[]): () => void;\n}\n\n/**\n * Types of event listeners of the {@link Wallets} API.\n *\n * @group App\n */\nexport interface WalletsEventsListeners {\n    /**\n     * Emitted when Wallets are registered.\n     *\n     * @param wallets Wallets that were registered.\n     */\n    register(...wallets: Wallet[]): void;\n\n    /**\n     * Emitted when Wallets are unregistered.\n     *\n     * @param wallets Wallets that were unregistered.\n     */\n    unregister(...wallets: Wallet[]): void;\n}\n\n/**\n * Names of {@link WalletsEventsListeners} that can be listened for.\n *\n * @group App\n */\nexport type WalletsEventNames = keyof WalletsEventsListeners;\n\n/**\n * @deprecated Use {@link WalletsEventsListeners} instead.\n *\n * @group Deprecated\n */\nexport type WalletsEvents = WalletsEventsListeners;\n\nfunction register(...wallets: Wallet[]): () => void {\n    // Filter out wallets that have already been registered.\n    // This prevents the same wallet from being registered twice, but it also prevents wallets from being\n    // unregistered by reusing a reference to the wallet to obtain the unregister function for it.\n    wallets = wallets.filter((wallet) => !registeredWalletsSet.has(wallet));\n    // If there are no new wallets to register, just return a no-op unregister function.\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    if (!wallets.length) return () => {};\n\n    wallets.forEach((wallet) => addRegisteredWallet(wallet));\n    listeners['register']?.forEach((listener) => guard(() => listener(...wallets)));\n    // Return a function that unregisters the registered wallets.\n    return function unregister(): void {\n        wallets.forEach((wallet) => removeRegisteredWallet(wallet));\n        listeners['unregister']?.forEach((listener) => guard(() => listener(...wallets)));\n    };\n}\n\nlet cachedWalletsArray: readonly Wallet[] | undefined;\nfunction get(): readonly Wallet[] {\n    if (!cachedWalletsArray) {\n        cachedWalletsArray = [...registeredWalletsSet];\n    }\n    return cachedWalletsArray;\n}\n\nfunction on<E extends WalletsEventNames>(event: E, listener: WalletsEventsListeners[E]): () => void {\n    listeners[event]?.push(listener) || (listeners[event] = [listener]);\n    // Return a function that removes the event listener.\n    return function off(): void {\n        listeners[event] = listeners[event]?.filter((existingListener) => listener !== existingListener);\n    };\n}\n\nfunction guard(callback: () => void) {\n    try {\n        callback();\n    } catch (error) {\n        console.error(error);\n    }\n}\n\nclass AppReadyEvent extends Event implements WindowAppReadyEvent {\n    readonly #detail: WindowAppReadyEventAPI;\n\n    get detail() {\n        return this.#detail;\n    }\n\n    get type() {\n        return 'wallet-standard:app-ready' as const;\n    }\n\n    constructor(api: WindowAppReadyEventAPI) {\n        super('wallet-standard:app-ready', {\n            bubbles: false,\n            cancelable: false,\n            composed: false,\n        });\n        this.#detail = api;\n    }\n\n    /** @deprecated */\n    preventDefault(): never {\n        throw new Error('preventDefault cannot be called');\n    }\n\n    /** @deprecated */\n    stopImmediatePropagation(): never {\n        throw new Error('stopImmediatePropagation cannot be called');\n    }\n\n    /** @deprecated */\n    stopPropagation(): never {\n        throw new Error('stopPropagation cannot be called');\n    }\n}\n\n/**\n * @deprecated Use {@link getWallets} instead.\n *\n * @group Deprecated\n */\nexport function DEPRECATED_getWallets(): Wallets {\n    if (wallets) return wallets;\n    wallets = getWallets();\n    if (typeof window === 'undefined') return wallets;\n\n    const callbacks = (window as DEPRECATED_WalletsWindow).navigator.wallets || [];\n    if (!Array.isArray(callbacks)) {\n        console.error('window.navigator.wallets is not an array');\n        return wallets;\n    }\n\n    const { register } = wallets;\n    const push = (...callbacks: DEPRECATED_WalletsCallback[]): void =>\n        callbacks.forEach((callback) => guard(() => callback({ register })));\n    try {\n        Object.defineProperty((window as DEPRECATED_WalletsWindow).navigator, 'wallets', {\n            value: Object.freeze({ push }),\n        });\n    } catch (error) {\n        console.error('window.navigator.wallets could not be set');\n        return wallets;\n    }\n\n    push(...callbacks);\n    return wallets;\n}\n", "import { type Adapter, isVersionedTransaction, WalletReadyState } from '@solana/wallet-adapter-base';\nimport { isSolanaChain, type SolanaChain } from '@solana/wallet-standard-chains';\nimport {\n    SolanaSignAndSendTransaction,\n    type SolanaSignAndSendTransactionFeature,\n    type SolanaSignAndSendTransactionMethod,\n    type SolanaSignAndSendTransactionOutput,\n    SolanaSignIn,\n    type SolanaSignInFeature,\n    type SolanaSignInMethod,\n    type SolanaSignInOutput,\n    SolanaSignMessage,\n    type SolanaSignMessageFeature,\n    type SolanaSignMessageMethod,\n    type SolanaSignMessageOutput,\n    SolanaSignTransaction,\n    type SolanaSignTransactionFeature,\n    type SolanaSignTransactionMethod,\n    type SolanaSignTransactionOutput,\n    type SolanaTransactionVersion,\n} from '@solana/wallet-standard-features';\nimport { getEndpointForChain } from '@solana/wallet-standard-util';\nimport { Connection, Transaction, VersionedTransaction } from '@solana/web3.js';\nimport { getWallets } from '@wallet-standard/app';\nimport type { Wallet, WalletIcon } from '@wallet-standard/base';\nimport {\n    StandardConnect,\n    type StandardConnectFeature,\n    type StandardConnectMethod,\n    StandardDisconnect,\n    type StandardDisconnectFeature,\n    type StandardDisconnectMethod,\n    StandardEvents,\n    type StandardEventsFeature,\n    type StandardEventsListeners,\n    type StandardEventsNames,\n    type StandardEventsOnMethod,\n} from '@wallet-standard/features';\nimport { arraysEqual, bytesEqual, ReadonlyWalletAccount } from '@wallet-standard/wallet';\nimport bs58 from 'bs58';\n\n/** TODO: docs */\nexport class SolanaWalletAdapterWalletAccount extends ReadonlyWalletAccount {\n    // eslint-disable-next-line no-unused-private-class-members\n    readonly #adapter: Adapter;\n\n    constructor({\n        adapter,\n        address,\n        publicKey,\n        chains,\n    }: {\n        adapter: Adapter;\n        address: string;\n        publicKey: Uint8Array;\n        chains: readonly SolanaChain[];\n    }) {\n        const features: (keyof (SolanaSignAndSendTransactionFeature &\n            SolanaSignTransactionFeature &\n            SolanaSignMessageFeature &\n            SolanaSignInFeature))[] = [SolanaSignAndSendTransaction];\n        if ('signTransaction' in adapter) {\n            features.push(SolanaSignTransaction);\n        }\n        if ('signMessage' in adapter) {\n            features.push(SolanaSignMessage);\n        }\n        if ('signIn' in adapter) {\n            features.push(SolanaSignIn);\n        }\n\n        super({ address, publicKey, chains, features });\n        if (new.target === SolanaWalletAdapterWalletAccount) {\n            Object.freeze(this);\n        }\n\n        this.#adapter = adapter;\n    }\n}\n\n/** TODO: docs */\nexport class SolanaWalletAdapterWallet implements Wallet {\n    readonly #listeners: {\n        [E in StandardEventsNames]?: StandardEventsListeners[E][];\n    } = {};\n    readonly #adapter: Adapter;\n    readonly #supportedTransactionVersions: readonly SolanaTransactionVersion[];\n    readonly #chain: SolanaChain;\n    readonly #endpoint: string | undefined;\n    #account: SolanaWalletAdapterWalletAccount | undefined;\n\n    get version() {\n        return '1.0.0' as const;\n    }\n\n    get name() {\n        return this.#adapter.name;\n    }\n\n    get icon() {\n        return this.#adapter.icon as WalletIcon;\n    }\n\n    get chains() {\n        return [this.#chain];\n    }\n\n    get features(): StandardConnectFeature &\n        StandardDisconnectFeature &\n        StandardEventsFeature &\n        SolanaSignAndSendTransactionFeature &\n        Partial<SolanaSignTransactionFeature & SolanaSignMessageFeature & SolanaSignInFeature> {\n        const features: StandardConnectFeature &\n            StandardDisconnectFeature &\n            StandardEventsFeature &\n            SolanaSignAndSendTransactionFeature = {\n            [StandardConnect]: {\n                version: '1.0.0',\n                connect: this.#connect,\n            },\n            [StandardDisconnect]: {\n                version: '1.0.0',\n                disconnect: this.#disconnect,\n            },\n            [StandardEvents]: {\n                version: '1.0.0',\n                on: this.#on,\n            },\n            [SolanaSignAndSendTransaction]: {\n                version: '1.0.0',\n                supportedTransactionVersions: this.#supportedTransactionVersions,\n                signAndSendTransaction: this.#signAndSendTransaction,\n            },\n        };\n\n        let signTransactionFeature: SolanaSignTransactionFeature | undefined;\n        if ('signTransaction' in this.#adapter) {\n            signTransactionFeature = {\n                [SolanaSignTransaction]: {\n                    version: '1.0.0',\n                    supportedTransactionVersions: this.#supportedTransactionVersions,\n                    signTransaction: this.#signTransaction,\n                },\n            };\n        }\n\n        let signMessageFeature: SolanaSignMessageFeature | undefined;\n        if ('signMessage' in this.#adapter) {\n            signMessageFeature = {\n                [SolanaSignMessage]: {\n                    version: '1.0.0',\n                    signMessage: this.#signMessage,\n                },\n            };\n        }\n\n        let signInFeature: SolanaSignInFeature | undefined;\n        if ('signIn' in this.#adapter) {\n            signInFeature = {\n                [SolanaSignIn]: {\n                    version: '1.0.0',\n                    signIn: this.#signIn,\n                },\n            };\n        }\n\n        return { ...features, ...signTransactionFeature, ...signMessageFeature };\n    }\n\n    get accounts() {\n        return this.#account ? [this.#account] : [];\n    }\n\n    get endpoint() {\n        return this.#endpoint;\n    }\n\n    constructor(adapter: Adapter, chain: SolanaChain, endpoint?: string) {\n        if (new.target === SolanaWalletAdapterWallet) {\n            Object.freeze(this);\n        }\n\n        const supportedTransactionVersions = [...(adapter.supportedTransactionVersions || ['legacy'])];\n        if (!supportedTransactionVersions.length) {\n            supportedTransactionVersions.push('legacy');\n        }\n\n        this.#adapter = adapter;\n        this.#supportedTransactionVersions = supportedTransactionVersions;\n        this.#chain = chain;\n        this.#endpoint = endpoint;\n\n        adapter.on('connect', this.#connected, this);\n        adapter.on('disconnect', this.#disconnected, this);\n\n        this.#connected();\n    }\n\n    destroy(): void {\n        this.#adapter.off('connect', this.#connected, this);\n        this.#adapter.off('disconnect', this.#disconnected, this);\n    }\n\n    #connected(): void {\n        const publicKey = this.#adapter.publicKey?.toBytes();\n        if (publicKey) {\n            const address = this.#adapter.publicKey!.toBase58();\n            const account = this.#account;\n            if (\n                !account ||\n                account.address !== address ||\n                account.chains.includes(this.#chain) ||\n                !bytesEqual(account.publicKey, publicKey)\n            ) {\n                this.#account = new SolanaWalletAdapterWalletAccount({\n                    adapter: this.#adapter,\n                    address,\n                    publicKey,\n                    chains: [this.#chain],\n                });\n                this.#emit('change', { accounts: this.accounts });\n            }\n        }\n    }\n\n    #disconnected(): void {\n        if (this.#account) {\n            this.#account = undefined;\n            this.#emit('change', { accounts: this.accounts });\n        }\n    }\n\n    #connect: StandardConnectMethod = async ({ silent } = {}) => {\n        if (!silent && !this.#adapter.connected) {\n            await this.#adapter.connect();\n        }\n\n        this.#connected();\n\n        return { accounts: this.accounts };\n    };\n\n    #disconnect: StandardDisconnectMethod = async () => {\n        await this.#adapter.disconnect();\n    };\n\n    #on: StandardEventsOnMethod = (event, listener) => {\n        this.#listeners[event]?.push(listener) || (this.#listeners[event] = [listener]);\n        return (): void => this.#off(event, listener);\n    };\n\n    #emit<E extends StandardEventsNames>(event: E, ...args: Parameters<StandardEventsListeners[E]>): void {\n        // eslint-disable-next-line prefer-spread\n        this.#listeners[event]?.forEach((listener) => listener.apply(null, args));\n    }\n\n    #off<E extends StandardEventsNames>(event: E, listener: StandardEventsListeners[E]): void {\n        this.#listeners[event] = this.#listeners[event]?.filter((existingListener) => listener !== existingListener);\n    }\n\n    #deserializeTransaction(serializedTransaction: Uint8Array): Transaction | VersionedTransaction {\n        const transaction = VersionedTransaction.deserialize(serializedTransaction);\n        if (!this.#supportedTransactionVersions.includes(transaction.version))\n            throw new Error('unsupported transaction version');\n        if (transaction.version === 'legacy' && arraysEqual(this.#supportedTransactionVersions, ['legacy']))\n            return Transaction.from(serializedTransaction);\n        return transaction;\n    }\n\n    #signAndSendTransaction: SolanaSignAndSendTransactionMethod = async (...inputs) => {\n        const outputs: SolanaSignAndSendTransactionOutput[] = [];\n\n        if (inputs.length === 1) {\n            const input = inputs[0]!;\n            if (input.account !== this.#account) throw new Error('invalid account');\n            if (!isSolanaChain(input.chain)) throw new Error('invalid chain');\n            const transaction = this.#deserializeTransaction(input.transaction);\n            const { commitment, preflightCommitment, skipPreflight, maxRetries, minContextSlot } = input.options || {};\n            const endpoint = getEndpointForChain(input.chain, this.#endpoint);\n            const connection = new Connection(endpoint, commitment || 'confirmed');\n\n            const latestBlockhash = commitment\n                ? await connection.getLatestBlockhash({\n                      commitment: preflightCommitment || commitment,\n                      minContextSlot,\n                  })\n                : undefined;\n\n            const signature = await this.#adapter.sendTransaction(transaction, connection, {\n                preflightCommitment,\n                skipPreflight,\n                maxRetries,\n                minContextSlot,\n            });\n\n            if (latestBlockhash) {\n                await connection.confirmTransaction(\n                    {\n                        ...latestBlockhash,\n                        signature,\n                    },\n                    commitment || 'confirmed'\n                );\n            }\n\n            outputs.push({ signature: bs58.decode(signature) });\n        } else if (inputs.length > 1) {\n            // Adapters have no `sendAllTransactions` method, so just sign and send each transaction in serial.\n            for (const input of inputs) {\n                outputs.push(...(await this.#signAndSendTransaction(input)));\n            }\n        }\n\n        return outputs;\n    };\n\n    #signTransaction: SolanaSignTransactionMethod = async (...inputs) => {\n        if (!('signTransaction' in this.#adapter)) throw new Error('signTransaction not implemented by adapter');\n        const outputs: SolanaSignTransactionOutput[] = [];\n\n        if (inputs.length === 1) {\n            const input = inputs[0]!;\n            if (input.account !== this.#account) throw new Error('invalid account');\n            if (input.chain && !isSolanaChain(input.chain)) throw new Error('invalid chain');\n            const transaction = this.#deserializeTransaction(input.transaction);\n\n            const signedTransaction = await this.#adapter.signTransaction(transaction);\n\n            const serializedTransaction = isVersionedTransaction(signedTransaction)\n                ? signedTransaction.serialize()\n                : new Uint8Array(\n                      signedTransaction.serialize({\n                          requireAllSignatures: false,\n                          verifySignatures: false,\n                      })\n                  );\n\n            outputs.push({ signedTransaction: serializedTransaction });\n        } else if (inputs.length > 1) {\n            for (const input of inputs) {\n                if (input.account !== this.#account) throw new Error('invalid account');\n                if (input.chain && !isSolanaChain(input.chain)) throw new Error('invalid chain');\n            }\n            const transactions = inputs.map(({ transaction }) => this.#deserializeTransaction(transaction));\n\n            const signedTransactions = await this.#adapter.signAllTransactions(transactions);\n\n            outputs.push(\n                ...signedTransactions.map((signedTransaction) => {\n                    const serializedTransaction = isVersionedTransaction(signedTransaction)\n                        ? signedTransaction.serialize()\n                        : new Uint8Array(\n                              signedTransaction.serialize({\n                                  requireAllSignatures: false,\n                                  verifySignatures: false,\n                              })\n                          );\n\n                    return { signedTransaction: serializedTransaction };\n                })\n            );\n        }\n\n        return outputs;\n    };\n\n    #signMessage: SolanaSignMessageMethod = async (...inputs) => {\n        if (!('signMessage' in this.#adapter)) throw new Error('signMessage not implemented by adapter');\n        const outputs: SolanaSignMessageOutput[] = [];\n\n        if (inputs.length === 1) {\n            const input = inputs[0]!;\n            if (input.account !== this.#account) throw new Error('invalid account');\n\n            const signature = await this.#adapter.signMessage(input.message);\n\n            outputs.push({ signedMessage: input.message, signature });\n        } else if (inputs.length > 1) {\n            // Adapters have no `signAllMessages` method, so just sign each message in serial.\n            for (const input of inputs) {\n                outputs.push(...(await this.#signMessage(input)));\n            }\n        }\n\n        return outputs;\n    };\n\n    #signIn: SolanaSignInMethod = async (...inputs) => {\n        if (!('signIn' in this.#adapter)) throw new Error('signIn not implemented by adapter');\n\n        if (inputs.length > 1) {\n            // Adapters don't support `signIn` with multiple inputs, so just sign in with each input in serial.\n            const outputs: SolanaSignInOutput[] = [];\n            for (const input of inputs) {\n                outputs.push(await this.#adapter.signIn(input));\n            }\n            return outputs;\n        } else {\n            return [await this.#adapter.signIn(inputs[0])];\n        }\n    };\n}\n\n/** TODO: docs */\nexport function registerWalletAdapter(\n    adapter: Adapter,\n    chain: SolanaChain,\n    endpoint?: string,\n    match: (wallet: Wallet) => boolean = (wallet) => wallet.name === adapter.name\n): () => void {\n    const { register, get, on } = getWallets();\n    const destructors: (() => void)[] = [];\n\n    function destroy(): void {\n        destructors.forEach((destroy) => destroy());\n        destructors.length = 0;\n    }\n\n    function setup(): boolean {\n        // If the adapter is unsupported, or a standard wallet that matches it has already been registered, do nothing.\n        if (adapter.readyState === WalletReadyState.Unsupported || get().some(match)) return true;\n\n        // If the adapter isn't ready, try again later.\n        const ready =\n            adapter.readyState === WalletReadyState.Installed || adapter.readyState === WalletReadyState.Loadable;\n        if (ready) {\n            const wallet = new SolanaWalletAdapterWallet(adapter, chain, endpoint);\n            destructors.push(() => wallet.destroy());\n            // Register the adapter wrapped as a standard wallet, and receive a function to unregister the adapter.\n            destructors.push(register(wallet));\n            // Whenever a standard wallet is registered ...\n            destructors.push(\n                on('register', (...wallets) => {\n                    // ... check if it matches the adapter.\n                    if (wallets.some(match)) {\n                        // If it does, remove the event listener and unregister the adapter.\n                        destroy();\n                    }\n                })\n            );\n        }\n        return ready;\n    }\n\n    if (!setup()) {\n        function listener(): void {\n            if (setup()) {\n                adapter.off('readyStateChange', listener);\n            }\n        }\n\n        adapter.on('readyStateChange', listener);\n        destructors.push(() => adapter.off('readyStateChange', listener));\n    }\n\n    return destroy;\n}\n", "import type { Adapter, WalletName } from '@solana/wallet-adapter-base';\nimport { isWalletAdapterCompatibleWallet, StandardWalletAdapter } from '@solana/wallet-standard-wallet-adapter-base';\nimport { DEPRECATED_getWallets } from '@wallet-standard/app';\nimport type { Wallet } from '@wallet-standard/base';\nimport { useEffect, useMemo, useRef, useState } from 'react';\n\nexport function useStandardWalletAdapters(adapters: Adapter[]): Adapter[] {\n    const warnings = useConstant(() => new Set<WalletName>());\n    const { get, on } = useConstant(() => DEPRECATED_getWallets());\n    const [standardAdapters, setStandardAdapters] = useState(() => wrapWalletsWithAdapters(get()));\n\n    useEffect(() => {\n        const listeners = [\n            on('register', (...wallets) =>\n                setStandardAdapters((standardAdapters) => [...standardAdapters, ...wrapWalletsWithAdapters(wallets)])\n            ),\n            on('unregister', (...wallets) =>\n                setStandardAdapters((standardAdapters) =>\n                    standardAdapters.filter((standardAdapter) =>\n                        wallets.some((wallet) => wallet === standardAdapter.wallet)\n                    )\n                )\n            ),\n        ];\n        return () => listeners.forEach((off) => off());\n    }, [on]);\n\n    const prevStandardAdapters = usePrevious(standardAdapters);\n    useEffect(() => {\n        if (!prevStandardAdapters) return;\n\n        const currentAdapters = new Set(standardAdapters);\n        const removedAdapters = new Set(\n            prevStandardAdapters.filter((previousAdapter) => !currentAdapters.has(previousAdapter))\n        );\n        removedAdapters.forEach((adapter) => adapter.destroy());\n    }, [prevStandardAdapters, standardAdapters]);\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    useEffect(() => () => standardAdapters.forEach((adapter) => adapter.destroy()), []);\n\n    return useMemo(\n        () => [\n            ...standardAdapters,\n            ...adapters.filter(({ name }) => {\n                if (standardAdapters.some((standardAdapter) => standardAdapter.name === name)) {\n                    if (!warnings.has(name)) {\n                        warnings.add(name);\n                        console.warn(\n                            `${name} was registered as a Standard Wallet. The Wallet Adapter for ${name} can be removed from your app.`\n                        );\n                    }\n                    return false;\n                }\n                return true;\n            }),\n        ],\n        [standardAdapters, adapters, warnings]\n    );\n}\n\nfunction useConstant<T>(fn: () => T): T {\n    const ref = useRef<{ value: T }>(undefined);\n    if (ref.current === undefined) {\n        ref.current = { value: fn() };\n    }\n    return ref.current.value;\n}\n\nfunction usePrevious<T>(state: T): T | undefined {\n    const ref = useRef<T>(undefined);\n    useEffect(() => {\n        ref.current = state;\n    });\n    return ref.current;\n}\n\nfunction wrapWalletsWithAdapters(wallets: readonly Wallet[]): readonly StandardWalletAdapter[] {\n    return wallets.filter(isWalletAdapterCompatibleWallet).map((wallet) => new StandardWalletAdapter({ wallet }));\n}\n", "import {\n    createDefaultAddressSelector,\n    createDefaultAuthorizationResultCache,\n    createDefaultWalletNotFoundHandler,\n    SolanaMobileWalletAdapter,\n    SolanaMobileWalletAdapterWalletName,\n} from '@solana-mobile/wallet-adapter-mobile';\nimport { type Adapter, type WalletError, type WalletName } from '@solana/wallet-adapter-base';\nimport { useStandardWalletAdapters } from '@solana/wallet-standard-wallet-adapter-react';\nimport React, { type ReactNode, useCallback, useEffect, useMemo, useRef } from 'react';\nimport getEnvironment, { Environment } from './getEnvironment.js';\nimport getInferredClusterFromEndpoint from './getInferredClusterFromEndpoint.js';\nimport { useConnection } from './useConnection.js';\nimport { useLocalStorage } from './useLocalStorage.js';\nimport { WalletProviderBase } from './WalletProviderBase.js';\n\nexport interface WalletProviderProps {\n    children: ReactNode;\n    wallets: Adapter[];\n    autoConnect?: boolean | ((adapter: Adapter) => Promise<boolean>);\n    localStorageKey?: string;\n    onError?: (error: WalletError, adapter?: Adapter) => void;\n}\n\nlet _userAgent: string | null;\nfunction getUserAgent() {\n    if (_userAgent === undefined) {\n        _userAgent = globalThis.navigator?.userAgent ?? null;\n    }\n    return _userAgent;\n}\n\nfunction getIsMobile(adapters: Adapter[]) {\n    const userAgentString = getUserAgent();\n    return getEnvironment({ adapters, userAgentString }) === Environment.MOBILE_WEB;\n}\n\nfunction getUriForAppIdentity() {\n    const location = globalThis.location;\n    if (!location) return;\n    return `${location.protocol}//${location.host}`;\n}\n\nexport function WalletProvider({\n    children,\n    wallets: adapters,\n    autoConnect,\n    localStorageKey = 'walletName',\n    onError,\n}: WalletProviderProps) {\n    const { connection } = useConnection();\n    const adaptersWithStandardAdapters = useStandardWalletAdapters(adapters);\n    const mobileWalletAdapter = useMemo(() => {\n        if (!getIsMobile(adaptersWithStandardAdapters)) {\n            return null;\n        }\n        const existingMobileWalletAdapter = adaptersWithStandardAdapters.find(\n            (adapter) => adapter.name === SolanaMobileWalletAdapterWalletName\n        );\n        if (existingMobileWalletAdapter) {\n            return existingMobileWalletAdapter;\n        }\n        return new SolanaMobileWalletAdapter({\n            addressSelector: createDefaultAddressSelector(),\n            appIdentity: {\n                uri: getUriForAppIdentity(),\n            },\n            authorizationResultCache: createDefaultAuthorizationResultCache(),\n            cluster: getInferredClusterFromEndpoint(connection?.rpcEndpoint),\n            onWalletNotFound: createDefaultWalletNotFoundHandler(),\n        });\n    }, [adaptersWithStandardAdapters, connection?.rpcEndpoint]);\n    const adaptersWithMobileWalletAdapter = useMemo(() => {\n        if (mobileWalletAdapter == null || adaptersWithStandardAdapters.indexOf(mobileWalletAdapter) !== -1) {\n            return adaptersWithStandardAdapters;\n        }\n        return [mobileWalletAdapter, ...adaptersWithStandardAdapters];\n    }, [adaptersWithStandardAdapters, mobileWalletAdapter]);\n    const [walletName, setWalletName] = useLocalStorage<WalletName | null>(localStorageKey, null);\n    const adapter = useMemo(\n        () => adaptersWithMobileWalletAdapter.find((a) => a.name === walletName) ?? null,\n        [adaptersWithMobileWalletAdapter, walletName]\n    );\n    const changeWallet = useCallback(\n        (nextWalletName: WalletName<string> | null) => {\n            if (walletName === nextWalletName) return;\n            if (\n                adapter &&\n                // Selecting a wallet other than the mobile wallet adapter is not\n                // sufficient reason to call `disconnect` on the mobile wallet adapter.\n                // Calling `disconnect` on the mobile wallet adapter causes the entire\n                // authorization store to be wiped.\n                adapter.name !== SolanaMobileWalletAdapterWalletName\n            ) {\n                adapter.disconnect();\n            }\n            setWalletName(nextWalletName);\n        },\n        [adapter, setWalletName, walletName]\n    );\n    useEffect(() => {\n        if (!adapter) return;\n        function handleDisconnect() {\n            if (isUnloadingRef.current) return;\n            setWalletName(null);\n        }\n        adapter.on('disconnect', handleDisconnect);\n        return () => {\n            adapter.off('disconnect', handleDisconnect);\n        };\n    }, [adapter, adaptersWithStandardAdapters, setWalletName, walletName]);\n    const hasUserSelectedAWallet = useRef(false);\n    const handleAutoConnectRequest = useMemo(() => {\n        if (!autoConnect || !adapter) return;\n        return async () => {\n            // If autoConnect is true or returns true, use the default autoConnect behavior.\n            if (autoConnect === true || (await autoConnect(adapter))) {\n                if (hasUserSelectedAWallet.current) {\n                    await adapter.connect();\n                } else {\n                    await adapter.autoConnect();\n                }\n            }\n        };\n    }, [autoConnect, adapter]);\n    const isUnloadingRef = useRef(false);\n    useEffect(() => {\n        if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {\n            isUnloadingRef.current = false;\n            return;\n        }\n        function handleBeforeUnload() {\n            isUnloadingRef.current = true;\n        }\n        /**\n         * Some wallets fire disconnection events when the window unloads. Since there's no way to\n         * distinguish between a disconnection event received because a user initiated it, and one\n         * that was received because they've closed the window, we have to track window unload\n         * events themselves. Downstream components use this information to decide whether to act\n         * upon or drop wallet events and errors.\n         */\n        window.addEventListener('beforeunload', handleBeforeUnload);\n        return () => {\n            window.removeEventListener('beforeunload', handleBeforeUnload);\n        };\n    }, [adaptersWithStandardAdapters, walletName]);\n    const handleConnectError = useCallback(() => {\n        if (adapter) {\n            // If any error happens while connecting, unset the adapter.\n            changeWallet(null);\n        }\n    }, [adapter, changeWallet]);\n    const selectWallet = useCallback(\n        (walletName: WalletName | null) => {\n            hasUserSelectedAWallet.current = true;\n            changeWallet(walletName);\n        },\n        [changeWallet]\n    );\n    return (\n        <WalletProviderBase\n            wallets={adaptersWithMobileWalletAdapter}\n            adapter={adapter}\n            isUnloadingRef={isUnloadingRef}\n            onAutoConnectRequest={handleAutoConnectRequest}\n            onConnectError={handleConnectError}\n            onError={onError}\n            onSelectWallet={selectWallet}\n        >\n            {children}\n        </WalletProviderBase>\n    );\n}\n", "import { SolanaMobileWalletAdapterWalletName } from '@solana-mobile/wallet-adapter-mobile';\nimport { type Adapter, WalletReadyState } from '@solana/wallet-adapter-base';\n\nexport enum Environment {\n    DESKTOP_WEB,\n    MOBILE_WEB,\n}\n\ntype Config = Readonly<{\n    adapters: Adapter[];\n    userAgentString: string | null;\n}>;\n\nfunction isWebView(userAgentString: string) {\n    return /(WebView|Version\\/.+(Chrome)\\/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)|; wv\\).+(Chrome)\\/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+))/i.test(\n        userAgentString\n    );\n}\n\nexport default function getEnvironment({ adapters, userAgentString }: Config): Environment {\n    if (\n        adapters.some(\n            (adapter) =>\n                adapter.name !== SolanaMobileWalletAdapterWalletName &&\n                adapter.readyState === WalletReadyState.Installed\n        )\n    ) {\n        /**\n         * There are only two ways a browser extension adapter should be able to reach `Installed` status:\n         *\n         *     1. Its browser extension is installed.\n         *     2. The app is running on a mobile wallet's in-app browser.\n         *\n         * In either case, we consider the environment to be desktop-like.\n         */\n        return Environment.DESKTOP_WEB;\n    }\n    if (\n        userAgentString &&\n        // Step 1: Check whether we're on a platform that supports MWA at all.\n        /android/i.test(userAgentString) &&\n        // Step 2: Determine that we are *not* running in a WebView.\n        !isWebView(userAgentString)\n    ) {\n        return Environment.MOBILE_WEB;\n    } else {\n        return Environment.DESKTOP_WEB;\n    }\n}\n", "import { type Cluster } from '@solana/web3.js';\n\nexport default function getInferredClusterFromEndpoint(endpoint?: string): Cluster {\n    if (!endpoint) {\n        return 'mainnet-beta';\n    }\n    if (/devnet/i.test(endpoint)) {\n        return 'devnet';\n    } else if (/testnet/i.test(endpoint)) {\n        return 'testnet';\n    } else {\n        return 'mainnet-beta';\n    }\n}\n", "import {\n    type Adapter,\n    type MessageSignerWalletAdapterProps,\n    type SignerWalletAdapterProps,\n    type SignInMessageSignerWalletAdapterProps,\n    type WalletAdapterProps,\n    type WalletError,\n    type WalletName,\n    WalletNotConnectedError,\n    WalletNotReadyError,\n    WalletReadyState,\n} from '@solana/wallet-adapter-base';\nimport { type PublicKey } from '@solana/web3.js';\nimport React, { type ReactNode, useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { WalletNotSelectedError } from './errors.js';\nimport { WalletContext } from './useWallet.js';\n\nexport interface WalletProviderBaseProps {\n    children: ReactNode;\n    wallets: Adapter[];\n    adapter: Adapter | null;\n    isUnloadingRef: React.RefObject<boolean>;\n    // NOTE: The presence/absence of this handler implies that auto-connect is enabled/disabled.\n    onAutoConnectRequest?: () => Promise<void>;\n    onConnectError: () => void;\n    onError?: (error: WalletError, adapter?: Adapter) => void;\n    onSelectWallet: (walletName: WalletName | null) => void;\n}\n\nexport function WalletProviderBase({\n    children,\n    wallets: adapters,\n    adapter,\n    isUnloadingRef,\n    onAutoConnectRequest,\n    onConnectError,\n    onError,\n    onSelectWallet,\n}: WalletProviderBaseProps) {\n    const isConnectingRef = useRef(false);\n    const [connecting, setConnecting] = useState(false);\n    const isDisconnectingRef = useRef(false);\n    const [disconnecting, setDisconnecting] = useState(false);\n    const [publicKey, setPublicKey] = useState(() => adapter?.publicKey ?? null);\n    const [connected, setConnected] = useState(() => adapter?.connected ?? false);\n\n    /**\n     * Store the error handlers as refs so that a change in the\n     * custom error handler does not recompute other dependencies.\n     */\n    const onErrorRef = useRef(onError);\n    useEffect(() => {\n        onErrorRef.current = onError;\n        return () => {\n            onErrorRef.current = undefined;\n        };\n    }, [onError]);\n    const handleErrorRef = useRef((error: WalletError, adapter?: Adapter) => {\n        if (!isUnloadingRef.current) {\n            if (onErrorRef.current) {\n                onErrorRef.current(error, adapter);\n            } else {\n                console.error(error, adapter);\n                if (error instanceof WalletNotReadyError && typeof window !== 'undefined' && adapter) {\n                    window.open(adapter.url, '_blank');\n                }\n            }\n        }\n        return error;\n    });\n\n    // Wrap adapters to conform to the `Wallet` interface\n    const [wallets, setWallets] = useState(() =>\n        adapters\n            .map((adapter) => ({\n                adapter,\n                readyState: adapter.readyState,\n            }))\n            .filter(({ readyState }) => readyState !== WalletReadyState.Unsupported)\n    );\n\n    // When the adapters change, start to listen for changes to their `readyState`\n    useEffect(() => {\n        // When the adapters change, wrap them to conform to the `Wallet` interface\n        setWallets((wallets) =>\n            adapters\n                .map((adapter, index) => {\n                    const wallet = wallets[index];\n                    // If the wallet hasn't changed, return the same instance\n                    return wallet && wallet.adapter === adapter && wallet.readyState === adapter.readyState\n                        ? wallet\n                        : {\n                              adapter: adapter,\n                              readyState: adapter.readyState,\n                          };\n                })\n                .filter(({ readyState }) => readyState !== WalletReadyState.Unsupported)\n        );\n        function handleReadyStateChange(this: Adapter, readyState: WalletReadyState) {\n            setWallets((prevWallets) => {\n                const index = prevWallets.findIndex(({ adapter }) => adapter === this);\n                if (index === -1) return prevWallets;\n\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const { adapter } = prevWallets[index]!;\n                return [\n                    ...prevWallets.slice(0, index),\n                    { adapter, readyState },\n                    ...prevWallets.slice(index + 1),\n                ].filter(({ readyState }) => readyState !== WalletReadyState.Unsupported);\n            });\n        }\n        adapters.forEach((adapter) => adapter.on('readyStateChange', handleReadyStateChange, adapter));\n        return () => {\n            adapters.forEach((adapter) => adapter.off('readyStateChange', handleReadyStateChange, adapter));\n        };\n    }, [adapter, adapters]);\n\n    const wallet = useMemo(() => wallets.find((wallet) => wallet.adapter === adapter) ?? null, [adapter, wallets]);\n\n    // Setup and teardown event listeners when the adapter changes\n    useEffect(() => {\n        if (!adapter) return;\n\n        const handleConnect = (publicKey: PublicKey) => {\n            setPublicKey(publicKey);\n            isConnectingRef.current = false;\n            setConnecting(false);\n            setConnected(true);\n            isDisconnectingRef.current = false;\n            setDisconnecting(false);\n        };\n\n        const handleDisconnect = () => {\n            if (isUnloadingRef.current) return;\n\n            setPublicKey(null);\n            isConnectingRef.current = false;\n            setConnecting(false);\n            setConnected(false);\n            isDisconnectingRef.current = false;\n            setDisconnecting(false);\n        };\n\n        const handleError = (error: WalletError) => {\n            handleErrorRef.current(error, adapter);\n        };\n\n        adapter.on('connect', handleConnect);\n        adapter.on('disconnect', handleDisconnect);\n        adapter.on('error', handleError);\n\n        return () => {\n            adapter.off('connect', handleConnect);\n            adapter.off('disconnect', handleDisconnect);\n            adapter.off('error', handleError);\n\n            handleDisconnect();\n        };\n    }, [adapter, isUnloadingRef]);\n\n    // When the adapter changes, clear the `autoConnect` tracking flag\n    const didAttemptAutoConnectRef = useRef(false);\n    useEffect(() => {\n        return () => {\n            didAttemptAutoConnectRef.current = false;\n        };\n    }, [adapter]);\n\n    // If auto-connect is enabled, request to connect when the adapter changes and is ready\n    useEffect(() => {\n        if (\n            didAttemptAutoConnectRef.current ||\n            isConnectingRef.current ||\n            connected ||\n            !onAutoConnectRequest ||\n            !(wallet?.readyState === WalletReadyState.Installed || wallet?.readyState === WalletReadyState.Loadable)\n        )\n            return;\n\n        isConnectingRef.current = true;\n        setConnecting(true);\n        didAttemptAutoConnectRef.current = true;\n        (async function () {\n            try {\n                await onAutoConnectRequest();\n            } catch {\n                onConnectError();\n                // Drop the error. It will be caught by `handleError` anyway.\n            } finally {\n                setConnecting(false);\n                isConnectingRef.current = false;\n            }\n        })();\n    }, [connected, onAutoConnectRequest, onConnectError, wallet]);\n\n    // Send a transaction using the provided connection\n    const sendTransaction: WalletAdapterProps['sendTransaction'] = useCallback(\n        async (transaction, connection, options) => {\n            if (!adapter) throw handleErrorRef.current(new WalletNotSelectedError());\n            if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n            return await adapter.sendTransaction(transaction, connection, options);\n        },\n        [adapter, connected]\n    );\n\n    // Sign a transaction if the wallet supports it\n    const signTransaction: SignerWalletAdapterProps['signTransaction'] | undefined = useMemo(\n        () =>\n            adapter && 'signTransaction' in adapter\n                ? async (transaction) => {\n                      if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n                      return await adapter.signTransaction(transaction);\n                  }\n                : undefined,\n        [adapter, connected]\n    );\n\n    // Sign multiple transactions if the wallet supports it\n    const signAllTransactions: SignerWalletAdapterProps['signAllTransactions'] | undefined = useMemo(\n        () =>\n            adapter && 'signAllTransactions' in adapter\n                ? async (transactions) => {\n                      if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n                      return await adapter.signAllTransactions(transactions);\n                  }\n                : undefined,\n        [adapter, connected]\n    );\n\n    // Sign an arbitrary message if the wallet supports it\n    const signMessage: MessageSignerWalletAdapterProps['signMessage'] | undefined = useMemo(\n        () =>\n            adapter && 'signMessage' in adapter\n                ? async (message) => {\n                      if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n                      return await adapter.signMessage(message);\n                  }\n                : undefined,\n        [adapter, connected]\n    );\n\n    // Sign in if the wallet supports it\n    const signIn: SignInMessageSignerWalletAdapterProps['signIn'] | undefined = useMemo(\n        () =>\n            adapter && 'signIn' in adapter\n                ? async (input) => {\n                      return await adapter.signIn(input);\n                  }\n                : undefined,\n        [adapter]\n    );\n\n    const handleConnect = useCallback(async () => {\n        if (isConnectingRef.current || isDisconnectingRef.current || wallet?.adapter.connected) return;\n        if (!wallet) throw handleErrorRef.current(new WalletNotSelectedError());\n        const { adapter, readyState } = wallet;\n        if (!(readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable))\n            throw handleErrorRef.current(new WalletNotReadyError(), adapter);\n        isConnectingRef.current = true;\n        setConnecting(true);\n        try {\n            await adapter.connect();\n        } catch (e) {\n            onConnectError();\n            throw e;\n        } finally {\n            setConnecting(false);\n            isConnectingRef.current = false;\n        }\n    }, [onConnectError, wallet]);\n\n    const handleDisconnect = useCallback(async () => {\n        if (isDisconnectingRef.current) return;\n        if (!adapter) return;\n        isDisconnectingRef.current = true;\n        setDisconnecting(true);\n        try {\n            await adapter.disconnect();\n        } finally {\n            setDisconnecting(false);\n            isDisconnectingRef.current = false;\n        }\n    }, [adapter]);\n\n    return (\n        <WalletContext.Provider\n            value={{\n                autoConnect: !!onAutoConnectRequest,\n                wallets,\n                wallet,\n                publicKey,\n                connected,\n                connecting,\n                disconnecting,\n                select: onSelectWallet,\n                connect: handleConnect,\n                disconnect: handleDisconnect,\n                sendTransaction,\n                signTransaction,\n                signAllTransactions,\n                signMessage,\n                signIn,\n            }}\n        >\n            {children}\n        </WalletContext.Provider>\n    );\n}\n"],
  "mappings": "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",
  "names": ["import_react", "React", "import_react", "import_react", "import_react", "value", "_StandardWalletAdapter_connect", "_StandardWalletAdapter_connected", "_StandardWalletAdapter_disconnected", "_StandardWalletAdapter_reset", "_StandardWalletAdapter_signTransaction", "_StandardWalletAdapter_signAllTransactions", "_StandardWalletAdapter_signMessage", "_StandardWalletAdapter_signIn", "wallets", "__classPrivateFieldGet", "__classPrivateFieldSet", "register", "callbacks", "__classPrivateFieldSet", "__classPrivateFieldGet", "__classPrivateFieldSet", "_SolanaWalletAdapterWallet_disconnected", "_SolanaWalletAdapterWallet_emit", "_SolanaWalletAdapterWallet_off", "_SolanaWalletAdapterWallet_deserializeTransaction", "import_react", "get", "on", "listeners", "wallets", "standardAdapters", "import_react", "Environment", "import_react", "adapter", "wallets", "wallet", "readyState", "handleConnect", "publicKey", "handleDisconnect", "React", "adapter", "walletName", "React"]
}
