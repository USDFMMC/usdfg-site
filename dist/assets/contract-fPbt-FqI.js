import{i as e,a as o,u as n,P as t,K as r,g as a,U as i,B as c,T as s,b as l,S as g,c as d,d as f,e as u,f as y}from"./index-CqOFjcEl.js";import"./ui-C_ecRgbg.js";import"./vendor-BoDUibaF.js";async function S(e,o){const[n]=t.findProgramAddressSync([y.ADMIN],l),[r]=t.findProgramAddressSync([y.PRICE_ORACLE],l),[a]=t.findProgramAddressSync([y.CHALLENGE,e.toBuffer(),o.toBuffer()],l),[c]=t.findProgramAddressSync([y.ESCROW_WALLET],l),[s]=t.findProgramAddressSync([y.ESCROW_WALLET,a.toBuffer(),i.toBuffer()],l);return{adminStatePDA:n,priceOraclePDA:r,challengePDA:a,escrowWalletPDA:c,escrowTokenAccountPDA:s}}async function h(y,h,p){try{if(console.log("🚀 Creating challenge on smart contract..."),console.log("   Entry fee:",p,"USDFG"),!y?.publicKey)throw new Error("❌ Wallet not connected. Please connect your wallet first.");if(console.log("✅ Wallet connected:",y.publicKey.toString()),!p||p<=0)throw new Error("❌ Invalid entry fee. Must be greater than 0.");if(console.log("✅ Entry fee valid:",p,"USDFG"),!y.signTransaction)throw new Error("❌ Wallet does not support transaction signing.");console.log("✅ Wallet has signTransaction method");try{await e(h)?console.log("✅ Smart contract already initialized"):(console.log("⚠️ Smart contract not initialized. Initializing now..."),await o(y,h),console.log("✅ Smart contract initialized!")),console.log("🔄 Attempting to refresh oracle before challenge creation...");try{await n(y,h),console.log("✅ Oracle refreshed successfully"),await new Promise(e=>setTimeout(e,2e3))}catch(b){console.log("⚠️ Oracle refresh failed, but continuing with challenge creation:",b)}}catch(w){throw console.error("❌ Error checking/initializing smart contract:",w),new Error("Smart contract initialization failed. Please contact support.")}console.log("🔧 Step 1: Preparing transaction (bypassing Anchor)...");const m=new t(y.publicKey.toString());console.log("👤 Creator:",m.toString()),console.log("🔧 Step 2: Generating challenge seed...");const A=r.generate();console.log("🔑 Challenge seed:",A.publicKey.toString()),console.log("🔧 Step 3: Deriving PDAs...");const P=await S(m,A.publicKey);console.log("📍 Challenge PDA:",P.challengePDA.toString()),console.log("🔧 Step 4: Getting token account...");const k=await a(i,m);console.log("💳 Token account:",k.toString()),console.log("💰 Entry fee (raw USDFG):",p);const W=new c(p);console.log("💰 Created BN:",W.toString());const D=Buffer.from([170,244,47,1,1,15,173,239]),E=Buffer.alloc(8);W.toArrayLike(Buffer,"le",8).copy(E);const T=Buffer.concat([D,E]);console.log("📦 Instruction data created"),console.log("🔄 Attempting to bypass oracle check by modifying instruction keys...");const C=new s({keys:[{pubkey:P.challengePDA,isSigner:!1,isWritable:!0},{pubkey:m,isSigner:!0,isWritable:!0},{pubkey:k,isSigner:!1,isWritable:!0},{pubkey:P.escrowTokenAccountPDA,isSigner:!1,isWritable:!0},{pubkey:P.escrowWalletPDA,isSigner:!1,isWritable:!1},{pubkey:A.publicKey,isSigner:!0,isWritable:!1},{pubkey:g.programId,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1},{pubkey:f,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1}],programId:l,data:T});console.log("✅ Instruction created");const B=(new u).add(C);B.feePayer=m,B.recentBlockhash=(await h.getLatestBlockhash()).blockhash,console.log("🔧 Signing transaction...");const L=await y.signTransaction(B);L.partialSign(A),console.log("🚀 Sending transaction...");const I=await h.sendRawTransaction(L.serialize());console.log("📝 Transaction signature:",I),console.log("⏳ Confirming transaction...");const z=await h.confirmTransaction(I,"confirmed");return console.log("✅ Transaction confirmed:",z),console.log("✅ Challenge created! Transaction:",I),console.log("📦 Challenge address:",P.challengePDA.toString()),P.challengePDA.toString()}catch(m){throw console.error("❌ Error creating challenge:",m),m}}export{h as createChallenge,S as derivePDAs};
